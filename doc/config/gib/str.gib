//      str.gib
//
//      string routines for GIB in QuakeForge 0.5
//
//      Copyright (C) 2002  Brian Koropoff
//
//	This library is free software; you can redistribute it and/or
//	modify it under the terms of the GNU Lesser General Public
//	License as published by the Free Software Foundation; either
//	version 2.1 of the License, or (at your option) any later version.
//
//	This library is distributed in the hope that it will be useful,
//	but WITHOUT ANY WARRANTY; without even the implied warranty of
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//	Lesser General Public License for more details.
//
//	You should have received a copy of the GNU Lesser General Public
//	License along with this library; if not, write to the Free Software
//	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA


// Many of these string-manipulating expressions are pure evil.
// Eat your heart out, Larry.

// *****************************************************************************
// str_replace
// 	Replaces text between two positions in a string with a different string.
// 	Usage: str_replace base_string new_string start_position end_position
//	Returns: the new string
// *****************************************************************************

alias str_replace {
	basestr = $1
	newstr = $2
	pos1 = $3
	pos2 = $4
	return $basestr[0:#{$pos1-1}]$newstr$basestr[#{$pos2+1}:~{strlen $basestr}]
	// Ugh.  I think my punishment for creating such an ugly language
	// is having to write the standard "library" for it
}

// ********************************************************************************
// str_findsubstr
//	Finds the location of a substring within a string starting at any position.
//	Usage: str_findsubstr haystack needle [start_position]
//	Returns: The position of the substring or -1 if it wasn't found.
// ********************************************************************************

alias str_findsubstr {
	basestr = $1
	substr = $2
	if #{$argn < 4} {
		3 = 0; // Fill in the last argument if we didn't get it
	}
	for {i = $3; #{$i < ~{strlen $basestr}}; i = #{$i + 1}} {
		if ~{streq $substr $basestr[$i:#{$i + ~{strlen $substr} - 1}]} {
			return $i
		}
	}
	return -1
}

alias str_snip {
	basestr = $1
	pos1 = $2
	pos2 = $3
	return $basestr[0:#{$pos1-1}]$basestr[#{$pos2+1}:~{strlen $basestr}]
}

alias str_insert {
	basestr = $1
	newstr = $2
	pos = $3
	return $basestr[0:#{$pos}]$newstr$basestr[#{$pos+1}:~{strlen $basestr}]
}

alias str_escape {
	basestr = $1;
	toescape = $2;
	for {i = 0; #{$i < ~{strlen $basestr}}; i = #{$i+1}} {
		if #{~{str_findsubstr $toescape $basestr[$i]} >= 0} {
			basestr = ~{str_insert $basestr "\\" #{$i-1}}
			i = #{$i+1}
		}
	}
	return $basestr
}

alias str_gettoken {
	str = $1
	toknum = $2
	delim = $3
	pos = 0
	toknum = #{$toknum - 1}
	while $toknum {
		pos = ~{str_findsubstr $str $delim $pos}
		if #{$pos < 0} {
			return ""
		}
		pos = #{$pos + ~{strlen $delim}}
		toknum = #{$toknum - 1}
	}
	pos2 = ~{str_findsubstr $str $delim $pos}
	if #{$pos2 < 0} {
		return $str[$pos:~{strlen $str}]
	} else {
		return $str[$pos:#{$pos2-1}]
	}
}