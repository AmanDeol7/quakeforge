{
	search = (
		VkAttachmentDescription,
		VkDebugUtilsMessageSeverityFlagBitsEXT,
		VkPresentModeKHR,
		VkSubpassDescription,
		VkSubpassDependency,
		VkSpecializationInfo,
		VkPipelineShaderStageCreateInfo,
		VkPipelineVertexInputStateCreateInfo,
		VkPipelineInputAssemblyStateCreateInfo,
		VkPipelineViewportStateCreateInfo,
		VkPipelineRasterizationStateCreateInfo,
		VkPipelineMultisampleStateCreateInfo,
		VkPipelineDepthStencilStateCreateInfo,
		VkPipelineColorBlendStateCreateInfo,
		VkPipelineDynamicStateCreateInfo,
		VkDescriptorSetLayoutBinding,
		VkDescriptorSetLayoutCreateInfo,
		VkPushConstantRange,
		VkPipelineLayoutCreateInfo,
		VkGraphicsPipelineCreateInfo,
		VkComputePipelineCreateInfo,
		VkDescriptorPoolCreateInfo,
		VkSamplerCreateInfo,
		VkImageCreateInfo,
		VkImageViewCreateInfo,
		VkFramebufferCreateInfo,
		VkClearValue,
		VkPhysicalDeviceLimits,
		VkRenderPassCreateInfo,
		VkRenderPassMultiviewCreateInfo,

		qfv_subpass_t,
		qfv_output_t,

		qfv_imageinfo_t,
		qfv_imageviewinfo_t,
		qfv_dependencyinfo_t,
		qfv_attachmentinfo_t,
		qfv_attachmentrefinfo_t,
		qfv_attachmentsetinfo_t,
		qfv_taskinfo_t,
		qfv_pipelineinfo_t,
		qfv_subpassinfo_t,
		qfv_framebufferinfo_t,
		qfv_renderpassinfo_t,
		qfv_renderinfo_t,
		qfv_pipelinespec_t,
	);
	parse = {
		VkSubpassDescription = {
			flags = auto;
			pipelineBindPoint = auto;
			inputAttachments = {
				type = (array, VkAttachmentReference);
				size = inputAttachmentCount;
				values = pInputAttachments;
			};
			colorAttachments = {
				type = (array, VkAttachmentReference);
				size = colorAttachmentCount;
				values = pColorAttachments;
			};
			resolveAttachments = {
				type = (array, VkAttachmentReference);
				values = pResolveAttachments;
				matchSize = colorAttachments;
			};
			depthStencilAttachment = {
				type = (single, VkAttachmentReference);
				value = pDepthStencilAttachment;
			};
			preserveAttachments = {
				type = (array, uint32_t);
				size = preserveAttachmentCount;
				values = pPreserveAttachments;
			};
		};
		VkPhysicalDeviceLimits = readonly;
		VkRenderPassCreateInfo = {
			//flags = auto; reserved for future use (Bits enum does not exist)
			attachments = {
				type = (array, VkAttachmentDescription);
				size = attachmentCount;
				values = pAttachments;
			};
			subpasses = {
				type = (array, VkSubpassDescription);
				size = subpassCount;
				values = pSubpasses;
			};
			dependencies = {
				type = (array, VkSubpassDependency);
				size = dependencyCount;
				values = pDependencies;
			};
		};
		VkSpecializationInfo = {
			mapEntries = {
				type = (array, VkSpecializationMapEntry);
				size = mapEntryCount;
				values = pMapEntries;
			};
			data = {
				type = (custom,	(QFBinary, QFString),
						parse_specialization_data);
				fields = (dataSize, pData);
			};
		};
		VkPipelineShaderStageCreateInfo = {
			//flags = auto; reserved for future use (Bits enum does not exist)
			stage = auto;
			name = {
				type = string;
				string = pName;
			};
			module = {
				type = (custom,	QFString, parse_VkShaderModule);
				fields = (module);
			};
			specializationInfo = {
				type = (single, VkSpecializationInfo);
				value = pSpecializationInfo;
			};
		};
		VkShaderModuleCreateInfo = skip;
		VkDescriptorSetLayoutBinding = {
			binding = auto;
			descriptorType = auto;
			descriptorCount = auto;
			stageFlags = auto;
			// skip pImmutableSamplers (default to 0) until I know how it works
		};
		VkDescriptorSetLayoutCreateInfo = {
			flags = auto;
			bindings = {
				type = (array, VkDescriptorSetLayoutBinding);
				size = bindingCount;
				values = pBindings;
			};
		};
		VkDescriptorPoolCreateInfo = {
			flags = auto;
			maxSets = auto;
			bindings = {
				type = (array, VkDescriptorPoolSize);
				size = poolSizeCount;
				values = pPoolSizes;
			};
		};
		VkPipelineVertexInputStateCreateInfo = {
			//flags = auto; reserved for future use (Bits enum does not exist)
			bindings = {
				type = (array, VkVertexInputBindingDescription);
				size = vertexBindingDescriptionCount;
				values = pVertexBindingDescriptions;
			};
			attributes = {
				type = (array, VkVertexInputAttributeDescription);
				size = vertexAttributeDescriptionCount;
				values = pVertexAttributeDescriptions;
			};
		};
		VkPipelineInputAssemblyStateCreateInfo = {
			//flags = auto; reserved for future use (Bits enum does not exist)
			topology = auto;
			primitiveRestartEnable = auto;
		};
		VkPipelineViewportStateCreateInfo = {
			//flags = auto; reserved for future use (Bits enum does not exist)
			//FIXME redo as one array
			viewports = {
				type = (array, VkViewport);
				size = viewportCount;
				values = pViewports;
			};
			scissors = {
				type = (array, VkRect2D);
				size = scissorCount;
				values = pScissors;
			};
		};
		VkPipelineRasterizationStateCreateInfo = {
			//flags = auto; reserved for future use (Bits enum does not exist)
			depthClampEnable = auto;
			rasterizerDiscardEnable = auto;
			polygonMode = auto;
			cullMode = auto;
			frontFace = auto;
			depthBiasEnable = auto;
			depthBiasConstantFactor = auto;
			depthBiasClamp = auto;
			depthBiasSlopeFactor = auto;
			lineWidth = auto;
		};
		VkPipelineMultisampleStateCreateInfo = {
			//flags = auto; reserved for future use (Bits enum does not exist)
			rasterizationSamples = auto;
			sampleShadingEnable = auto;
			minSampleShading = auto;
			//pSampleMask = auto; FIXME disabled until correct size is known
			alphaToCoverageEnable = auto;
			alphaToOneEnable = auto;
		};
		VkPipelineDepthStencilStateCreateInfo = {
			//flags = auto; reserved for future use (Bits enum does not exist)
			depthTestEnable = auto;
			depthWriteEnable = auto;
			depthCompareOp = auto;
			depthBoundsTestEnable = auto;
			stencilTestEnable = auto;
			front = auto;
			back = auto;
			minDepthBounds = auto;
			maxDepthBounds = auto;
		};
		VkPipelineColorBlendStateCreateInfo = {
			//flags = auto; reserved for future use (Bits enum does not exist)
			logicOpEnable = auto;
			logicOp = auto;
			attachments = {
				type = (array, VkPipelineColorBlendAttachmentState);
				size = attachmentCount;
				values = pAttachments;
			};
			blendConstants = {
				type = (custom, QFString, parse_RGBA);
				fields = (blendConstants);
			};
		};
		VkPipelineDynamicStateCreateInfo = {
			//flags = auto; reserved for future use (Bits enum does not exist)
			dynamicState = {
				type = (array, VkDynamicState);
				size = dynamicStateCount;
				values = pDynamicStates;
			};
		};
		VkPipelineLayoutCreateInfo = {
			//flags = auto; reserved for future use (Bits enum does not exist)
			setLayouts = {
				type = (array,	{
									parse_type = (QFDictionary, QFString);
									type = VkDescriptorSetLayout;
									parser = parse_VkDescriptorSetLayout;
								});
				size = setLayoutCount;
				values = pSetLayouts;
			};
			pushConstantRanges = {
				type = (array, VkPushConstantRange);
				size = pushConstantRangeCount;
				values = pPushConstantRanges;
			};
		};
		VkPipelineTessellationStateCreateInfo = {
			//flags = auto; reserved for future use (Bits enum does not exist)
			patchControlPoints = auto;
		};
		VkGraphicsPipelineCreateInfo = {
			flags = auto;
			stages = {
				type = (array, VkPipelineShaderStageCreateInfo);
				size = stageCount;
				values = pStages;
			};
			vertexInput = {
				type = (single, VkPipelineVertexInputStateCreateInfo);
				value = pVertexInputState;
			};
			inputAssembly = {
				type = (single, VkPipelineInputAssemblyStateCreateInfo);
				value = pInputAssemblyState;
			};
			tessellation = {
				type = (single, VkPipelineTessellationStateCreateInfo);
				value = pTessellationState;
			};
			viewport = {
				type = (single, VkPipelineViewportStateCreateInfo);
				value = pViewportState;
			};
			rasterization = {
				type = (single, VkPipelineRasterizationStateCreateInfo);
				value = pRasterizationState;
			};
			multisample = {
				type = (single, VkPipelineMultisampleStateCreateInfo);
				value = pMultisampleState;
			};
			depthStencil = {
				type = (single, VkPipelineDepthStencilStateCreateInfo);
				value = pDepthStencilState;
			};
			colorBlend = {
				type = (single, VkPipelineColorBlendStateCreateInfo);
				value = pColorBlendState;
			};
			dynamic = {
				type = (single, VkPipelineDynamicStateCreateInfo);
				value = pDynamicState;
			};
			layout = {
				type = (custom,	QFString, parse_VkPipelineLayout);
				fields = (layout);
			};
			renderPass = {
				type = (custom,	QFString, parse_VkRenderPass);
				fields = (renderPass);
			};
			subpass = auto;
			basePipelineHandle = {
				type = (custom, QFString, parse_BasePipeline);
				fields = (basePipelineHandle);
			};
			basePipelineIndex = auto;
		};
		VkComputePipelineCreateInfo = {
			flags = auto;
			stage = auto;
			layout = {
				type = (custom,	QFString, parse_VkPipelineLayout);
				fields = (layout);
			};
			basePipelineHandle = {
				type = (custom, QFString, parse_BasePipeline);
				fields = (basePipelineHandle);
			};
			basePipelineIndex = auto;
		};
		VkImageCreateInfo = {
			flags = auto;
			imageType = auto;
			format = auto;
			extent = auto;
			mipLevels = auto;
			arrayLayers = auto;
			samples = auto;
			tiling = auto;
			usage = auto;
			sharingMode = skip;	// FIXME for now
			queueFamilyIndexCount = skip;	// FIXME for now
			pQueueFamilyIndices = skip;	// FIXME for now
			initialLayout = auto;
		};
		VkImageViewCreateInfo = {
			flags = auto;
			image = {
				type = (custom,	(QFDictionary, QFString),
						parse_VkImage);
				fields = (image);
			};
			viewType = auto;
			format = auto;
			components = auto;
			subresourceRange = auto;
		};
		VkFramebufferCreateInfo = {
			//flags = auto; reserved for future use (Bits enum does not exist)
			renderPass = {
				type = (custom,	QFString, parse_VkRenderPass);
				fields = (renderPass);
			};
			attachments = {
				type = (array, VkImageView);
				size = attachmentCount;
				values = pAttachments;
			};
			width = auto;
			height = auto;
			layers = auto;
		};
		VkClearColorValue = skip;
		VkClearValue = {
			color = {
				type = (custom, QFString, parse_RGBA);
				fields = (color);
			};
			depthStencil = auto;
		};
		VkRenderPassMultiviewCreateInfo = {
			viewMasks = {
				type = (array, uint32_t);
				size = subpassCount;
				values = pViewMasks;
			};
			viewOffsets = {
				type = (array, int32_t);
				size = dependencyCount;
				values = pViewOffsets;
			};
			correlationMasks = {
				type = (array, uint32_t);
				size = correlationMaskCount;
				values = pCorrelationMasks;
			};
		};

		qfv_subpass_s = {
			.name = qfv_subpass_t;
			color = {
				type = (custom, QFString, parse_RGBA);
				fields = (color);
			};
			name = {
				type = string;
				string = name;
			};
		};
		qfv_output_s = {
			.name = qfv_output_t;
			extent = auto;
			image = {
				type = (readonly, VkImage);
				value = image;
			};
			view = {
				type = (readonly, VkImageView);
				value = view;
			};
			format = auto;
			frames = auto;
			finalLayout = auto;
		};

		qfv_taskinfo_s = {
			.name = qfv_taskinfo_t;
			func = {
				type = (custom, QFString, parse_task_function);
				fields = (func, params, param_data);
			};
			params = {
				type = (custom,	QFArray, parse_task_params);
				fields = (func, params, param_data);
			};
		};
		qfv_attachmentrefinfo_s = {
			.name = qfv_attachmentrefinfo_t;
			.type = (QFString, QFDictionary);
			.string = {
				name = $name;
				layout = $auto;
			};
			.dictionary = {
				.parse = auto;
			};
			layout = auto;
			blend = auto;
		};
		qfv_attachmentsetinfo_s = {
			.name = qfv_attachmentsetinfo_t;
			input = {
				type = (labeledarray, qfv_attachmentrefinfo_t, name);
				size = num_input;
				values = input;
			};
			color = {
				type = (labeledarray, qfv_attachmentrefinfo_t, name);
				size = num_color;
				values = color;
			};
			resolve = {
				type = (labeledarray, qfv_attachmentrefinfo_t, name);
				values = resolve;
				matchSize = color;
			};
			depth = {
				type = (labeledsingle, qfv_attachmentrefinfo_t, name);
				value = depth;
			};
			preserve = {
				type = (array,  {
									parse_type = QFString;
									type = "char *";
									parser = parse_string;
									data = parse_string_array;
								});
				size = num_preserve;
				values = preserve;
			};
		};
		qfv_pipelineinfo_s = {
			.name = qfv_pipelineinfo_t;
			color = auto;
			name = {
				type = string;
				string = name;
			};
			tasks = {
				type = (array, qfv_taskinfo_t);
				size = num_tasks;
				values = tasks;
			};

			flags = auto;
			stages = {
				type = (array, VkPipelineShaderStageCreateInfo);
				size = num_graph_stages;
				values = graph_stages;
			};
			vertexInput = {
				type = (single, VkPipelineVertexInputStateCreateInfo);
				value = vertexInput;
			};
			inputAssembly = {
				type = (single, VkPipelineInputAssemblyStateCreateInfo);
				value = inputAssembly;
			};
			tessellation = {
				type = (single, VkPipelineTessellationStateCreateInfo);
				value = tessellation;
			};
			viewport = {
				type = (single, VkPipelineViewportStateCreateInfo);
				value = viewport;
			};
			rasterization = {
				type = (single, VkPipelineRasterizationStateCreateInfo);
				value = rasterization;
			};
			multisample = {
				type = (single, VkPipelineMultisampleStateCreateInfo);
				value = multisample;
			};
			depthStencil = {
				type = (single, VkPipelineDepthStencilStateCreateInfo);
				value = depthStencil;
			};
			colorBlend = {
				type = (single, VkPipelineColorBlendStateCreateInfo);
				value = colorBlend;
			};
			dynamic = {
				type = (single, VkPipelineDynamicStateCreateInfo);
				value = dynamic;
			};
			layout = {
				type = (single, qfv_reference_t);
				value = layout;
			};
		};
		qfv_subpassinfo_s = {
			.name = qfv_subpassinfo_t;
			name = {
				type = string;
				string = name;
			};
			color = auto;
			dependencies = {
				type = (labeledarray, qfv_dependencyinfo_t, name);
				size = num_dependencies;
				values = dependencies;
			};
			attachments = {
				type = (single, qfv_attachmentsetinfo_t);
				value = attachments;
			};
			pipelines = {
				type = (labeledarray, qfv_pipelineinfo_t, name);
				size = num_pipelines;
				values = pipelines;
			};
			base_pipeline = {
				//type = (labeledsingle, qfv_pipelineinfo_t, name);
				type = (single, qfv_pipelineinfo_t, name);
				value = base_pipeline;
			};
		};
		qfv_framebufferinfo_s = {
			.name = qfv_framebufferinfo_t;
			attachments = {
				type = (array, qfv_reference_t);
				size = num_attachments;
				values = attachments;
			};
			width = auto;
			height = auto;
			layers = auto;
		};
		qfv_reference_s = {
			.name = qfv_reference_t;
			.type = QFString;
			.string = {
				name = $item.string;
				line = $item.line;
			};
		};
		qfv_renderpassinfo_s = {
			.name = qfv_renderpassinfo_t;
			attachments = {
				type = (labeledarray, qfv_attachmentinfo_t, name);
				size = num_attachments;
				values = attachments;
			};
			framebuffer = auto;
			subpasses = {
				type = (labeledarray, qfv_subpassinfo_t, name);
				size = num_subpasses;
				values = subpasses;
			};
		};
		qfv_renderinfo_s = {
			.name = qfv_renderinfo_t;
			properties = ignore;
			images = {
				type = (labeledarray, qfv_imageinfo_t, name);
				size = num_images;
				values = images;
			};
			views = {
				type = (labeledarray, qfv_imageviewinfo_t, name);
				size = num_views;
				values = views;
			};
			renderpasses = {
				type = (labeledarray, qfv_renderpassinfo_t, name);
				size = num_renderpasses;
				values = renderpasses;
			};
		};
	};
}
