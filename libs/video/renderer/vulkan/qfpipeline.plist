{
	shaderModules = {
		// specify shader modules to load into memory
		// key is the name of the module for referecy by the pipeline
		// value the path to the spv file to load
		// $shader refers to the shader install path
		// $builtin refers to compiled-in shaders
		passthrough = $builtin/passthrough.vert;
		pushcolor = $builtin/pushcolor.frag;
		twodv = $builtin/twod.vert;
		twodf = $builtin/twod.frag;
	};
	samplers = {
		quakepic = {
			magFilter = nearest;
			minFilter = nearest;
			mipmapMode = nearest;
			addressModeU = clamp_to_edge;
			addressModeV = clamp_to_edge;
			addressModeW = clamp_to_edge;
			mipLodBias = 0;
			anisotropyEnable = 0;//FIXME false!!!
			maxAnisotropy = 0;
			compareEnable = 0;//FIXME false!!!
			compareOp = always;
			minLod = 0;
			maxLod = 0;
			borderColor = float_transparent_black;
			unnormalizedCoordinates = 1;//FIXME true!!!
		};
	};
	descriptorPools = {
		twod = {
			flags = 0;
			maxSets = $swapchain.images.size;
			bindings = (
				{
					type = uniform_buffer;
					descriptorCount = $swapchain.images.size;
				},
				{
					type = combined_image_sampler;
					descriptorCount = $swapchain.images.size;
				},
			);
		};
	};
	setLayouts = {
		twod = {
			bindings = (
				{
					binding = 0;
					descriptorType = uniform_buffer;
					descriptorCount = 1;
					stageFlags = vertex;
				},
				{
					binding = 1;
					descriptorType = combined_image_sampler;
					descriptorCount = 1;
					stageFlags = fragment;
				},
			);
		};
		something = {
			flags = 0;
			bindings = (
				{
					binding = 0;
					descriptorType = sampled_image;
					descriptorCount = 1;
					stageFlags = fragment;
				},
				{
					binding = 1;
					descriptorType = uniform_buffer;
					descriptorCount = 1;
					stageFlags = vertex;
				},
			);
		};
	};
	pipelineLayouts = {
		twod = {
			setLayouts = (twod);
		};
		something = {
			setLayouts = (something);
			pushConstantRanges = (
				{
					stageFlags = fragment;
					offset = 0;
					size = "4 * 4";
				},
			);
		};
	};
	pipelines = {
		twod = {
			stages = (
				{ stage = vertex; name = main; module = twodv; },
				{ stage = fragment; name = main; module = twodf; },
			);
			vertexInput = {
				bindings = (
					{
						binding = 0;
						stride = "2 * 4 * 4";
						inputRate = vertex;
					},
				);
				attributes = (
					{
						location = 0;
						binding = 0;
						format = r32g32_sfloat;
						offset = 0;
					},
					{
						location = 1;
						binding = 0;
						format = r32g32_sint;
						offset = 8;
					},
					{
						location = 2;
						binding = 0;
						format = r32g32b32a32_sfloat;
						offset = 16;
					},
				);
			};
			inputAssembly = {
				topology = triangle_strip;
				primitiveRestartEnable = 1;
			};
			viewport = {
				viewports = (
					{
						x = 0; y = 0;
						width = 640; height = 480;
						minDepth = 0; maxDepth = 1;
					}
				);
				scissors = (
					{
						offset = { x = 0; y = 0 };
						extent = { width = 640; height = 480; };
					},
				);
			};
			rasterization = {
				depthClampEnable = 0;
				rasterizerDiscardEnable = 0;
				polygonMode = fill;
				cullMode = back;
				frontFace = counter_clockwise;
				depthBiasEnable = 0;
				lineWidth = 1;
			};
			multisample = {
				rasterizationSamples = $msaaSamples;
				sampleShadingEnable = 0;
				minSampleShading = 0.5f;
				alphaToCoverageEnable = 0;
				alphaToOneEnable = 0;
			};
			depthStencil = {
				depthTestEnable = 1;
				depthWriteEnable = 1;
				depthCompareOp = less;
				depthBoundsTestEnable = 0;
				stencilTestEnable = 0;
			};
			colorBlend = {
				logicOpEnable = 0;
				attachments = ({
					blendEnable = 0;
					srcColorBlendFactor = src_color;
					dstColorBlendFactor = zero;
					colorBlendOp = add;
					srcAlphaBlendFactor = src_alpha;
					dstAlphaBlendFactor = zero;
					alphaBlendOp = add;
					colorWriteMask = r|g|b|a;
				});
			};
			dynamic = {
				dynamicState = ( viewport, scissor );
			};
			layout = twod;
			//renderPass = renderpass;
		};
	};
	renderpass = {
		attachments = (
			{
				flags = 0;
				format = $swapchain.format;
				samples = $msaaSamples;
				loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;
				storeOp = VK_ATTACHMENT_STORE_OP_STORE;
				stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
				stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
				initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
				finalLayout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;
			},
			{
				flags = 0;
				format = VK_FORMAT_D32_SFLOAT;
				samples = $msaaSamples;
				loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;
				storeOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
				stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
				stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
				initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
				finalLayout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;
			},
			{
				flags = 0;
				format = $swapchain.format;
				samples = VK_SAMPLE_COUNT_1_BIT;
				loadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
				storeOp = VK_ATTACHMENT_STORE_OP_STORE;
				stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
				stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
				initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
				finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;
			},
		);
		subpasses = (
			{
				pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;
				colorAttachments = (
					{
						attachment = 0;
						layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;
					}
				);
				resolveAttachments = (
					{
						attachment = 2;
						layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;
					}
				);
				depthStencilAttachment = {
					attachment = 1;
					layout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;
				};
				preserveAttachments = ();
			},
		);
		dependencies = (
			{
				srcSubpass = VK_SUBPASS_EXTERNAL;
				dstSubpass = 0;
				srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
				dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
				srcAccessMask = 0;
				dstAccessMask = "VK_ACCESS_COLOR_ATTACHMENT_READ_BIT | VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT";
				dependencyFlags = 0;
			}
		);
	};
}
