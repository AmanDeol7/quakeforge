{
	samplers = {
		quakepic = {
			magFilter = nearest;
			minFilter = nearest;
			mipmapMode = nearest;
			addressModeU = clamp_to_edge;
			addressModeV = clamp_to_edge;
			addressModeW = clamp_to_edge;
			mipLodBias = 0;
			anisotropyEnable = false;
			maxAnisotropy = 0;
			compareEnable = false;
			compareOp = always;
			minLod = 0;
			maxLod = 0;
			borderColor = float_transparent_black;
			unnormalizedCoordinates = false;
		};
		quakebsp_sampler = {
			magFilter = linear;
			minFilter = linear;
			mipmapMode = linear;
			addressModeU = repeat;
			addressModeV = repeat;
			addressModeW = repeat;
			mipLodBias = 0;
			anisotropyEnable = false;
			maxAnisotropy = 0;
			compareEnable = false;
			compareOp = always;
			minLod = 0;
			maxLod = 4;
			borderColor = float_transparent_black;
			unnormalizedCoordinates = false;
		};
		alias_sampler = {
			magFilter = linear;
			minFilter = linear;
			mipmapMode = linear;
			addressModeU = clamp_to_edge;
			addressModeV = clamp_to_edge;
			addressModeW = clamp_to_edge;
			mipLodBias = 0;
			anisotropyEnable = false;
			maxAnisotropy = 0;
			compareEnable = false;
			compareOp = always;
			minLod = 0;
			maxLod = 1000;
			borderColor = float_transparent_black;
			unnormalizedCoordinates = false;
		};
	};
	descriptorPools = {
		twod_pool = {
			flags = 0;
			maxSets = $frames.size;
			bindings = (
				{
					type = uniform_buffer;
					descriptorCount = $frames.size;
				},
				{
					type = combined_image_sampler;
					descriptorCount = $frames.size;
				},
			);
		};
		alias_pool = {
			flags = 0;
			maxSets = "2z * $frames.size";
			bindings = (
				{
					type = uniform_buffer;
					descriptorCount = "2z * $frames.size";
				},
			);
		};
		lighting_attach_pool = {
			flags = 0;
			maxSets = $frames.size;
			bindings = (
				{
					type = input_attachment;
					descriptorCount = "3z * $frames.size";
				},
			);
		};
		lighting_lights_pool = {
			flags = 0;
			maxSets = $frames.size;
			bindings = (
				{
					type = uniform_buffer;
					descriptorCount = $frames.size;
				},
			);
		};
		compose_attach_pool = {
			flags = 0;
			maxSets = $frames.size;
			bindings = (
				{
					type = input_attachment;
					descriptorCount = "2z * $frames.size";
				},
			);
		};
	};
	setLayouts = {
		twod_set = {
			bindings = (
				{
					binding = 0;
					descriptorType = uniform_buffer;
					descriptorCount = 1;
					stageFlags = vertex;
				},
				{
					binding = 1;
					descriptorType = combined_image_sampler;
					descriptorCount = 1;
					stageFlags = fragment;
				},
			);
		};
		quakebsp_set = {
			flags = push_descriptor;
			bindings = (
				{
					binding = 0;
					descriptorType = uniform_buffer;
					descriptorCount = 1;
					stageFlags = vertex;
				},
				{
					binding = 1;
					descriptorType = combined_image_sampler;
					descriptorCount = 1;
					stageFlags = fragment;
				},
				{
					binding = 2;
					descriptorType = combined_image_sampler;
					descriptorCount = 1;
					stageFlags = fragment;
				},
				{
					binding = 3;
					descriptorType = combined_image_sampler;
					descriptorCount = 1;
					stageFlags = fragment;
				},
				{
					binding = 4;
					descriptorType = combined_image_sampler;
					descriptorCount = 1;
					stageFlags = fragment;
				},
				{
					binding = 5;
					descriptorType = combined_image_sampler;
					descriptorCount = 1;
					stageFlags = fragment;
				},
			);
		};
		alias_set = {
			flags = push_descriptor;
			bindings = (
				{
					binding = 0;
					descriptorType = uniform_buffer;
					descriptorCount = 1;
					stageFlags = vertex;
				},
				{
					binding = 1;
					descriptorType = combined_image_sampler;
					descriptorCount = 1;
					stageFlags = fragment;
				},
			);
		};
		alias_matrices = {
			bindings = (
				{
					binding = 0;
					descriptorType = uniform_buffer;
					descriptorCount = 1;
					stageFlags = vertex;
				},
			);
		};
		alias_textures = {
			flags = push_descriptor;
			bindings = (
				{
					binding = 0;
					descriptorType = combined_image_sampler;
					descriptorCount = 1;
					stageFlags = fragment;
				},
				{
					binding = 1;
					descriptorType = combined_image_sampler;
					descriptorCount = 1;
					stageFlags = fragment;
				},
				{
					binding = 2;
					descriptorType = combined_image_sampler;
					descriptorCount = 1;
					stageFlags = fragment;
				},
				{
					binding = 3;
					descriptorType = combined_image_sampler;
					descriptorCount = 1;
					stageFlags = fragment;
				},
			);
		};
		alias_lights = {
			bindings = (
				{
					binding = 0;
					descriptorType = uniform_buffer;
					descriptorCount = 1;
					stageFlags = fragment;
				},
			);
		};
		lighting_attach = {
			bindings = (
				{
					binding = 0;
					descriptorType = input_attachment;
					descriptorCount = 1;
					stageFlags = fragment;
				},
				{
					binding = 1;
					descriptorType = input_attachment;
					descriptorCount = 1;
					stageFlags = fragment;
				},
				{
					binding = 2;
					descriptorType = input_attachment;
					descriptorCount = 1;
					stageFlags = fragment;
				},
			);
		};
		lighting_lights = {
			bindings = (
				{
					binding = 0;
					descriptorType = uniform_buffer;
					descriptorCount = 1;
					stageFlags = fragment;
				},
			);
		};
		compose_attach = {
			bindings = (
				{
					binding = 0;
					descriptorType = input_attachment;
					descriptorCount = 1;
					stageFlags = fragment;
				},
				{
					binding = 1;
					descriptorType = input_attachment;
					descriptorCount = 1;
					stageFlags = fragment;
				},
			);
		};
	};
	pipelineLayouts = {
		twod_layout = {
			setLayouts = (twod_set);
		};
		quakebsp_layout = {
			setLayouts = (quakebsp_set);
			pushConstantRanges = (
				{
					stageFlags = vertex;
					offset = 0;
					size = "16 * 4";
				},
				{
					stageFlags = fragment;
					offset = 64;
					size = 32;
				},
			);
		};
		alias_layout = {
			//setLayouts = (alias_matrices, alias_lights, alias_textures);
			setLayouts = (alias_set);
			pushConstantRanges = (
				{
					stageFlags = vertex;
					offset = 0;
					size = "16 * 4 + 4";
				},
				{
					stageFlags = fragment;
					offset = 68;
					size = "3 * 4 + 2 * 4 * 4";
				},
			);
		};
		lighting_layout = {
			setLayouts = (lighting_attach, lighting_lights);
		};
		compose_layout = {
			setLayouts = (compose_attach);
		};
	};
	pipelines = {
		alias_depth = {
			subpass = 0;
			stages = (
				{
					stage = vertex;
					name = main;
					module = $builtin/alias_depth.vert;
				},
			);
			vertexInput = {
				bindings = (
					"$properties.pipelines.alias_gbuf.vertexInput.bindings[0]",
					"$properties.pipelines.alias_gbuf.vertexInput.bindings[1]",
				);
				attributes = (
					"$properties.pipelines.alias_gbuf.vertexInput.attributes[0]",
					"$properties.pipelines.alias_gbuf.vertexInput.attributes[1]",
					"$properties.pipelines.alias_gbuf.vertexInput.attributes[2]",
					"$properties.pipelines.alias_gbuf.vertexInput.attributes[3]",
				);
			};
			inputAssembly = $properties.pipelines.alias_gbuf.inputAssembly;
			viewport = $properties.pipelines.alias_gbuf.viewport;
			rasterization = $properties.pipelines.alias_gbuf.rasterization;
			multisample = $properties.pipelines.alias_gbuf.multisample;
			depthStencil = {
				depthTestEnable = true;
				depthWriteEnable = true;
				depthCompareOp = less_or_equal;
				depthBoundsTestEnable = false;
				stencilTestEnable = false;
			};
			colorBlend = $properties.pipelines.alias_gbuf.colorBlend;
			dynamic = {
				dynamicState = ( viewport, scissor );
			};
			layout = alias_layout;
			//renderPass = renderpass;
		};
		alias_gbuf = {
			subpass = 1;
			stages = (
				{
					stage = vertex;
					name = main;
					module = $builtin/alias.vert;
				},
				{
					stage = fragment;
					name = main;
					module = $builtin/alias_gbuf.frag;
					specializationInfo = {
						mapEntries = (
							{ size = 4; offset = 0; constantID = 0; },
						);
						data = <00000008>;
					};
				},
			);
			vertexInput = {
				bindings = (
					{
						binding = 0;
						stride = "2 * 4 * 4";
						inputRate = vertex;
					},
					{
						binding = 1;
						stride = "2 * 4 * 4";
						inputRate = vertex;
					},
					{
						binding = 2;
						stride = "2 * 4";
						inputRate = vertex;
					},
				);
				attributes = (
					{
						location = 0;
						binding = 0;
						format = r32g32b32a32_sfloat;
						offset = 0;
					},
					{
						location = 1;
						binding = 0;
						format = r32g32b32a32_sfloat;
						offset = 16;
					},
					{
						location = 2;
						binding = 1;
						format = r32g32b32a32_sfloat;
						offset = 0;
					},
					{
						location = 3;
						binding = 1;
						format = r32g32b32a32_sfloat;
						offset = 16;
					},
					{
						location = 4;
						binding = 2;
						format = r32g32_sfloat;
						offset = 0;
					},
				);
			};
			inputAssembly = {
				topology = triangle_list;
				primitiveRestartEnable = false;
			};
			viewport = {
				viewports = (
					{
						x = 0; y = 0;
						width = 640; height = 480;
						minDepth = 0; maxDepth = 1;
					}
				);
				scissors = (
					{
						offset = { x = 0; y = 0 };
						extent = { width = 640; height = 480; };
					},
				);
			};
			rasterization = {
				depthClampEnable = false;
				rasterizerDiscardEnable = false;
				polygonMode = fill;
				cullMode = back;
				frontFace = clockwise;
				depthBiasEnable = false;
				lineWidth = 1;
			};
			multisample = {
				rasterizationSamples = $msaaSamples;
				sampleShadingEnable = false;
				minSampleShading = 0.5f;
				alphaToCoverageEnable = false;
				alphaToOneEnable = false;
			};
			depthStencil = {
				depthTestEnable = true;
				depthWriteEnable = true;
				depthCompareOp = less_or_equal;
				depthBoundsTestEnable = false;
				stencilTestEnable = false;
			};
			colorBlend = {
				logicOpEnable = false;
				attachments = (
					{
						blendEnable = false;
						srcColorBlendFactor = src_alpha;
						dstColorBlendFactor = one_minus_src_alpha;
						colorBlendOp = add;
						srcAlphaBlendFactor = src_alpha;
						dstAlphaBlendFactor = one_minus_src_alpha;
						alphaBlendOp = add;
						colorWriteMask = r|g|b|a;
					},
					{
						blendEnable = false;
						srcColorBlendFactor = src_alpha;
						dstColorBlendFactor = one_minus_src_alpha;
						colorBlendOp = add;
						srcAlphaBlendFactor = src_alpha;
						dstAlphaBlendFactor = one_minus_src_alpha;
						alphaBlendOp = add;
						colorWriteMask = r|g|b|a;
					},
				);
			};
			dynamic = {
				dynamicState = ( viewport, scissor, blend_constants );
			};
			layout = alias_layout;
			//renderPass = renderpass;
		};
		bsp_depth = {
			subpass = 0;
			stages = (
				{
					stage = vertex;
					name = main;
					module = $builtin/bsp_depth.vert;
				},
			);
			vertexInput = {
				bindings = (
					"$properties.pipelines.bsp_gbuf.vertexInput.bindings[0]",
				);
				attributes = (
					"$properties.pipelines.bsp_gbuf.vertexInput.attributes[0]",
				);
			};
			inputAssembly = $properties.pipelines.bsp_gbuf.inputAssembly;
			viewport = $properties.pipelines.bsp_gbuf.viewport;
			rasterization = $properties.pipelines.bsp_gbuf.rasterization;
			multisample = $properties.pipelines.bsp_gbuf.multisample;
			depthStencil = {
				depthTestEnable = true;
				depthWriteEnable = true;
				depthCompareOp = less_or_equal;
				depthBoundsTestEnable = false;
				stencilTestEnable = false;
			};
			colorBlend = $properties.pipelines.bsp_gbuf.colorBlend;
			dynamic = {
				dynamicState = ( viewport, scissor );
			};
			layout = quakebsp_layout;
			//renderPass = renderpass;
		};
		bsp_gbuf = {
			subpass = 1;
			stages = (
				{
					stage = vertex;
					name = main;
					module = $builtin/bsp_gbuf.vert;
				},
				{
					stage = geometry;
					name = main;
					module = $builtin/bsp_gbuf.geom;
				},
				{
					stage = fragment;
					name = main;
					module = $builtin/bsp_gbuf.frag;
				},
			);
			vertexInput = {
				bindings = (
					{
						binding = 0;
						stride = "2 * 4 * 4";
						inputRate = vertex;
					},
				);
				attributes = (
					{
						location = 0;
						binding = 0;
						format = r32g32b32a32_sfloat;
						offset = 0;
					},
					{
						location = 1;
						binding = 0;
						format = r32g32b32a32_sfloat;
						offset = 16;
					},
				);
			};
			inputAssembly = {
				topology = triangle_fan;
				primitiveRestartEnable = true;
			};
			viewport = {
				viewports = (
					{
						x = 0; y = 0;
						width = 640; height = 480;
						minDepth = 0; maxDepth = 1;
					}
				);
				scissors = (
					{
						offset = { x = 0; y = 0 };
						extent = { width = 640; height = 480; };
					},
				);
			};
			rasterization = {
				depthClampEnable = false;
				rasterizerDiscardEnable = false;
				polygonMode = fill;
				cullMode = back;
				frontFace = clockwise;
				depthBiasEnable = false;
				lineWidth = 1;
			};
			multisample = {
				rasterizationSamples = $msaaSamples;
				sampleShadingEnable = false;
				minSampleShading = 0.5f;
				alphaToCoverageEnable = false;
				alphaToOneEnable = false;
			};
			depthStencil = {
				depthTestEnable = true;
				depthWriteEnable = true;
				depthCompareOp = less_or_equal;
				depthBoundsTestEnable = false;
				stencilTestEnable = false;
			};
			colorBlend = {
				logicOpEnable = false;
				attachments = (
					{
						blendEnable = false;
						srcColorBlendFactor = src_alpha;
						dstColorBlendFactor = one_minus_src_alpha;
						colorBlendOp = add;
						srcAlphaBlendFactor = src_alpha;
						dstAlphaBlendFactor = one_minus_src_alpha;
						alphaBlendOp = add;
						colorWriteMask = r|g|b|a;
					},
					{
						blendEnable = false;
						srcColorBlendFactor = src_alpha;
						dstColorBlendFactor = one_minus_src_alpha;
						colorBlendOp = add;
						srcAlphaBlendFactor = src_alpha;
						dstAlphaBlendFactor = one_minus_src_alpha;
						alphaBlendOp = add;
						colorWriteMask = r|g|b|a;
					}
				);
			};
			dynamic = {
				dynamicState = ( viewport, scissor, blend_constants );
			};
			layout = quakebsp_layout;
			//renderPass = renderpass;
		};
		bsp_skysheet = {
			subpass = 2;
			stages = (
				{
					stage = vertex;
					name = main;
					module = $builtin/bsp_gbuf.vert;
				},
				{
					stage = fragment;
					name = main;
					module = $builtin/bsp_sky.frag;
					specializationInfo = {
						mapEntries = (
							{ size = 4; offset = 0; constantID = 0; },
							{ size = 4; offset = 4; constantID = 1; },
						);
						data = <00000000ffffffff>;
					};
				},
			);
			vertexInput = $properties.pipelines.bsp_gbuf.vertexInput;
			inputAssembly = $properties.pipelines.bsp_gbuf.inputAssembly;
			viewport = $properties.pipelines.bsp_gbuf.viewport;
			rasterization = $properties.pipelines.bsp_gbuf.rasterization;
			multisample = $properties.pipelines.bsp_gbuf.multisample;
			depthStencil = $properties.pipelines.bsp_gbuf.depthStencil;
			colorBlend = {
				logicOpEnable = false;
				attachments = (
					{
						blendEnable = false;
						srcColorBlendFactor = src_alpha;
						dstColorBlendFactor = one_minus_src_alpha;
						colorBlendOp = add;
						srcAlphaBlendFactor = src_alpha;
						dstAlphaBlendFactor = one_minus_src_alpha;
						alphaBlendOp = add;
						colorWriteMask = r|g|b|a;
					},
				);
			};
			dynamic = {
				dynamicState = ( viewport, scissor );
			};
			layout = quakebsp_layout;
			//renderPass = renderpass;
		};
		twod = {
			subpass = 3;
			stages = (
				{
					stage = vertex;
					name = main;
					module = $builtin/twod.vert;
				},
				{
					stage = fragment;
					name = main;
					module = $builtin/twod.frag;
				},
			);
			vertexInput = {
				bindings = (
					{
						binding = 0;
						stride = "2 * 4 * 4";
						inputRate = vertex;
					},
				);
				attributes = (
					{
						location = 0;
						binding = 0;
						format = r32g32_sfloat;
						offset = 0;
					},
					{
						location = 1;
						binding = 0;
						format = r32g32_sfloat;
						offset = 8;
					},
					{
						location = 2;
						binding = 0;
						format = r32g32b32a32_sfloat;
						offset = 16;
					},
				);
			};
			inputAssembly = {
				topology = triangle_strip;
				primitiveRestartEnable = true;
			};
			viewport = {
				viewports = (
					{
						x = 0; y = 0;
						width = 640; height = 480;
						minDepth = 0; maxDepth = 1;
					}
				);
				scissors = (
					{
						offset = { x = 0; y = 0 };
						extent = { width = 640; height = 480; };
					},
				);
			};
			rasterization = {
				depthClampEnable = false;
				rasterizerDiscardEnable = false;
				polygonMode = fill;
				cullMode = back;
				frontFace = counter_clockwise;
				depthBiasEnable = false;
				lineWidth = 1;
			};
			multisample = {
				rasterizationSamples = $msaaSamples;
				sampleShadingEnable = false;
				minSampleShading = 0.5f;
				alphaToCoverageEnable = false;
				alphaToOneEnable = false;
			};
			depthStencil = {
				depthTestEnable = true;
				depthWriteEnable = true;
				depthCompareOp = less_or_equal;
				depthBoundsTestEnable = false;
				stencilTestEnable = false;
			};
			colorBlend = {
				logicOpEnable = false;
				attachments = ({
					blendEnable = true;
					srcColorBlendFactor = src_alpha;
					dstColorBlendFactor = one_minus_src_alpha;
					colorBlendOp = add;
					srcAlphaBlendFactor = src_alpha;
					dstAlphaBlendFactor = one_minus_src_alpha;
					alphaBlendOp = add;
					colorWriteMask = r|g|b|a;
				});
			};
			dynamic = {
				dynamicState = ( viewport, scissor );
			};
			layout = twod_layout;
			//renderPass = renderpass;
		};
		lighting = {
			subpass = 2;
			stages = (
				{
					stage = vertex;
					name = main;
					module = $builtin/passthrough.vert;
				},
				{
					stage = fragment;
					name = main;
					module = $builtin/lighting.frag;
				},
			);
			vertexInput = {
				bindings = (
					{
						binding = 0;
						stride = "4 * 4";
						inputRate = vertex;
					},
				);
				attributes = (
					{
						location = 0;
						binding = 0;
						format = r32g32b32a32_sfloat;
						offset = 0;
					},
				);
			};
			inputAssembly = {
				topology = triangle_strip;
				primitiveRestartEnable = false;
			};
			viewport = {
				viewports = (
					{
						x = 0; y = 0;
						width = 640; height = 480;
						minDepth = 0; maxDepth = 1;
					}
				);
				scissors = (
					{
						offset = { x = 0; y = 0 };
						extent = { width = 640; height = 480; };
					},
				);
			};
			rasterization = {
				depthClampEnable = false;
				rasterizerDiscardEnable = false;
				polygonMode = fill;
				cullMode = back;
				frontFace = counter_clockwise;
				depthBiasEnable = false;
				lineWidth = 1;
			};
			multisample = {
				rasterizationSamples = $msaaSamples;
				sampleShadingEnable = false;
				minSampleShading = 0.5f;
				alphaToCoverageEnable = false;
				alphaToOneEnable = false;
			};
			depthStencil = {
				depthTestEnable = false;
				depthWriteEnable = false;
				depthCompareOp = less_or_equal;
				depthBoundsTestEnable = false;
				stencilTestEnable = false;
			};
			colorBlend = {
				logicOpEnable = false;
				attachments = (
					{
						blendEnable = false;
						srcColorBlendFactor = src_alpha;
						dstColorBlendFactor = one_minus_src_alpha;
						colorBlendOp = add;
						srcAlphaBlendFactor = src_alpha;
						dstAlphaBlendFactor = one_minus_src_alpha;
						alphaBlendOp = add;
						colorWriteMask = r|g|b|a;
					},
				);
			};
			dynamic = {
				dynamicState = ( viewport, scissor );
			};
			layout = lighting_layout;
			//renderPass = renderpass;
		};
		compose = {
			subpass = 4;
			stages = (
				{
					stage = vertex;
					name = main;
					module = $builtin/passthrough.vert;
				},
				{
					stage = fragment;
					name = main;
					module = $builtin/compose.frag;
				},
			);
			vertexInput = {
				bindings = (
					{
						binding = 0;
						stride = "4 * 4";
						inputRate = vertex;
					},
				);
				attributes = (
					{
						location = 0;
						binding = 0;
						format = r32g32b32a32_sfloat;
						offset = 0;
					},
				);
			};
			inputAssembly = {
				topology = triangle_strip;
				primitiveRestartEnable = false;
			};
			viewport = {
				viewports = (
					{
						x = 0; y = 0;
						width = 640; height = 480;
						minDepth = 0; maxDepth = 1;
					}
				);
				scissors = (
					{
						offset = { x = 0; y = 0 };
						extent = { width = 640; height = 480; };
					},
				);
			};
			rasterization = {
				depthClampEnable = false;
				rasterizerDiscardEnable = false;
				polygonMode = fill;
				cullMode = back;
				frontFace = counter_clockwise;
				depthBiasEnable = false;
				lineWidth = 1;
			};
			multisample = {
				rasterizationSamples = $msaaSamples;
				sampleShadingEnable = false;
				minSampleShading = 0.5f;
				alphaToCoverageEnable = false;
				alphaToOneEnable = false;
			};
			depthStencil = {
				depthTestEnable = false;
				depthWriteEnable = false;
				depthCompareOp = less_or_equal;
				depthBoundsTestEnable = false;
				stencilTestEnable = false;
			};
			colorBlend = {
				logicOpEnable = false;
				attachments = (
					{
						blendEnable = false;
						srcColorBlendFactor = src_alpha;
						dstColorBlendFactor = one_minus_src_alpha;
						colorBlendOp = add;
						srcAlphaBlendFactor = src_alpha;
						dstAlphaBlendFactor = one_minus_src_alpha;
						alphaBlendOp = add;
						colorWriteMask = r|g|b|a;
					},
				);
			};
			dynamic = {
				dynamicState = ( viewport, scissor );
			};
			layout = compose_layout;
			//renderPass = renderpass;
		};
	};
	renderpass = {
		attachments = (
			{
				flags = 0;
				format = $swapchain.format;
				samples = 1;
				loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;
				storeOp = VK_ATTACHMENT_STORE_OP_STORE;
				stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
				stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
				initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
				finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;
			},
			{
				flags = 0;
				format = VK_FORMAT_D32_SFLOAT;
				samples = 1;
				loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;
				storeOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
				stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
				stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
				initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
				finalLayout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;
			},
		);
		subpasses = (
			{
				pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;
				colorAttachments = (
					{
						attachment = 0;
						layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;
					}
				);
				depthStencilAttachment = {
					attachment = 1;
					layout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;
				};
				preserveAttachments = ();
			},
		);
		dependencies = (
			{
				srcSubpass = VK_SUBPASS_EXTERNAL;
				dstSubpass = 0;
				srcStageMask = VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT;
				dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
				srcAccessMask = VK_ACCESS_MEMORY_READ_BIT;
				dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;
				dependencyFlags = VK_DEPENDENCY_BY_REGION_BIT;
			},
			{
				srcSubpass = 0;
				dstSubpass = VK_SUBPASS_EXTERNAL;
				srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
				dstStageMask = VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT;
				srcAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;
				dstAccessMask = VK_ACCESS_MEMORY_READ_BIT;
				dependencyFlags = VK_DEPENDENCY_BY_REGION_BIT;
			},
		);
	};
	renderpass_msaa = {
		attachments = (
			{
				flags = 0;
				format = $swapchain.format;
				samples = VK_SAMPLE_COUNT_1_BIT;
				loadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
				storeOp = VK_ATTACHMENT_STORE_OP_STORE;
				stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
				stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
				initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
				finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;
			},
			{
				flags = 0;
				format = VK_FORMAT_D32_SFLOAT;
				samples = $msaaSamples;
				loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;
				storeOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
				stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
				stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
				initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
				finalLayout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;
			},
			{
				flags = 0;
				format = $swapchain.format;
				samples = $msaaSamples;
				loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;
				storeOp = VK_ATTACHMENT_STORE_OP_STORE;
				stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
				stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
				initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
				finalLayout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;
			},
		);
		subpasses = (
			{
				pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;
				colorAttachments = (
					{
						attachment = 2;
						layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;
					}
				);
				resolveAttachments = (
					{
						attachment = 0;
						layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;
					}
				);
				depthStencilAttachment = {
					attachment = 1;
					layout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;
				};
				preserveAttachments = ();
			},
		);
		dependencies = (
			{
				srcSubpass = VK_SUBPASS_EXTERNAL;
				dstSubpass = 0;
				srcStageMask = VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT;
				dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
				srcAccessMask = VK_ACCESS_MEMORY_READ_BIT;
				dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;
				dependencyFlags = VK_DEPENDENCY_BY_REGION_BIT;
			},
			{
				srcSubpass = 0;
				dstSubpass = VK_SUBPASS_EXTERNAL;
				srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
				dstStageMask = VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT;
				srcAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;
				dstAccessMask = VK_ACCESS_MEMORY_READ_BIT;
				dependencyFlags = VK_DEPENDENCY_BY_REGION_BIT;
			},
		);
	};
}
