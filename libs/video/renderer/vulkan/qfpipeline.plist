{
	shaderModules = {
		// specify shader modules to load into memory
		// key is the name of the module for referecy by the pipeline
		// value the path to the spv file to load
		// $shader refers to the shader install path
		// $builtin refers to compiled-in shaders
		passthrough = $builtin/passthrough.vert;
		pushcolor = $builtin/pushcolor.frag;
		twodv = $builtin/twod.vert;
		twodf = $builtin/twod.frag;
		quakebspv = $builtin/quakebsp.vert;
		quakebspf = $builtin/quakebsp.frag;
	};
	samplers = {
		quakepic = {
			magFilter = nearest;
			minFilter = nearest;
			mipmapMode = nearest;
			addressModeU = clamp_to_edge;
			addressModeV = clamp_to_edge;
			addressModeW = clamp_to_edge;
			mipLodBias = 0;
			anisotropyEnable = false;
			maxAnisotropy = 0;
			compareEnable = false;
			compareOp = always;
			minLod = 0;
			maxLod = 0;
			borderColor = float_transparent_black;
			unnormalizedCoordinates = false;
		};
		quakebsp = {
			magFilter = linear;
			minFilter = linear;
			mipmapMode = linear;
			addressModeU = repeat;
			addressModeV = repeat;
			addressModeW = repeat;
			mipLodBias = 0;
			anisotropyEnable = false;
			maxAnisotropy = 0;
			compareEnable = false;
			compareOp = always;
			minLod = 0;
			maxLod = 1;
			borderColor = float_transparent_black;
			unnormalizedCoordinates = false;
		};
	};
	descriptorPools = {
		twod = {
			flags = 0;
			maxSets = $framebuffers.size;
			bindings = (
				{
					type = uniform_buffer;
					descriptorCount = $framebuffers.size;
				},
				{
					type = combined_image_sampler;
					descriptorCount = $framebuffers.size;
				},
			);
		};
	};
	setLayouts = {
		twod = {
			bindings = (
				{
					binding = 0;
					descriptorType = uniform_buffer;
					descriptorCount = 1;
					stageFlags = vertex;
				},
				{
					binding = 1;
					descriptorType = combined_image_sampler;
					descriptorCount = 1;
					stageFlags = fragment;
				},
			);
		};
		quakebsp = {
			flags = push_descriptor;
			bindings = (
				{
					binding = 0;
					descriptorType = uniform_buffer;
					descriptorCount = 1;
					stageFlags = vertex;
				},
				{
					binding = 1;
					descriptorType = combined_image_sampler;
					descriptorCount = 1;
					stageFlags = fragment;
				},
				{
					binding = 2;
					descriptorType = combined_image_sampler;
					descriptorCount = 1;
					stageFlags = fragment;
				},
				{
					binding = 3;
					descriptorType = combined_image_sampler;
					descriptorCount = 1;
					stageFlags = fragment;
				},
				{
					binding = 4;
					descriptorType = combined_image_sampler;
					descriptorCount = 1;
					stageFlags = fragment;
				},
				/*{
					binding = 5;
					descriptorType = combined_image_sampler;
					descriptorCount = 1;
					stageFlags = fragment;
				},*/
			);
		};
		something = {
			flags = 0;
			bindings = (
				{
					binding = 0;
					descriptorType = sampled_image;
					descriptorCount = 1;
					stageFlags = fragment;
				},
				{
					binding = 1;
					descriptorType = uniform_buffer;
					descriptorCount = 1;
					stageFlags = vertex;
				},
			);
		};
	};
	pipelineLayouts = {
		twod = {
			setLayouts = (twod);
		};
		quakebsp = {
			setLayouts = (quakebsp);
			pushConstantRanges = (
				{
					stageFlags = vertex;
					offset = 0;
					size = "16 * 4";
				},
				{
					stageFlags = fragment;
					offset = 64;
					size = 32;
				},
			);
		};
		something = {
			setLayouts = (something);
			pushConstantRanges = (
				{
					stageFlags = fragment;
					offset = 0;
					size = "4 * 4";
				},
			);
		};
	};
	pipelines = {
		quakebsp.main = {
			stages = (
				{ stage = vertex; name = main; module = quakebspv; },
				{ stage = fragment; name = main; module = quakebspf; },
			);
			vertexInput = {
				bindings = (
					{
						binding = 0;
						stride = "2 * 4 * 4";
						inputRate = vertex;
					},
				);
				attributes = (
					{
						location = 0;
						binding = 0;
						format = r32g32b32a32_sfloat;
						offset = 0;
					},
					{
						location = 1;
						binding = 0;
						format = r32g32b32a32_sfloat;
						offset = 8;
					},
				);
			};
			inputAssembly = {
				topology = triangle_fan;
				primitiveRestartEnable = true;
			};
			viewport = {
				viewports = (
					{
						x = 0; y = 0;
						width = 640; height = 480;
						minDepth = 0; maxDepth = 1;
					}
				);
				scissors = (
					{
						offset = { x = 0; y = 0 };
						extent = { width = 640; height = 480; };
					},
				);
			};
			rasterization = {
				depthClampEnable = false;
				rasterizerDiscardEnable = false;
				polygonMode = fill;
				cullMode = back;
				frontFace = clockwise;
				depthBiasEnable = false;
				lineWidth = 1;
			};
			multisample = {
				rasterizationSamples = $msaaSamples;
				sampleShadingEnable = false;
				minSampleShading = 0.5f;
				alphaToCoverageEnable = false;
				alphaToOneEnable = false;
			};
			depthStencil = {
				depthTestEnable = true;
				depthWriteEnable = true;
				depthCompareOp = less_or_equal;
				depthBoundsTestEnable = false;
				stencilTestEnable = false;
			};
			colorBlend = {
				logicOpEnable = false;
				attachments = ({
					blendEnable = true;
					srcColorBlendFactor = src_alpha;
					dstColorBlendFactor = one_minus_src_alpha;
					colorBlendOp = add;
					srcAlphaBlendFactor = src_alpha;
					dstAlphaBlendFactor = one_minus_src_alpha;
					alphaBlendOp = add;
					colorWriteMask = r|g|b|a;
				});
			};
			dynamic = {
				dynamicState = ( viewport, scissor, blend_constants );
			};
			layout = quakebsp;
			//renderPass = renderpass;
		};
		twod = {
			stages = (
				{ stage = vertex; name = main; module = twodv; },
				{ stage = fragment; name = main; module = twodf; },
			);
			vertexInput = {
				bindings = (
					{
						binding = 0;
						stride = "2 * 4 * 4";
						inputRate = vertex;
					},
				);
				attributes = (
					{
						location = 0;
						binding = 0;
						format = r32g32_sfloat;
						offset = 0;
					},
					{
						location = 1;
						binding = 0;
						format = r32g32_sfloat;
						offset = 8;
					},
					{
						location = 2;
						binding = 0;
						format = r32g32b32a32_sfloat;
						offset = 16;
					},
				);
			};
			inputAssembly = {
				topology = triangle_strip;
				primitiveRestartEnable = true;
			};
			viewport = {
				viewports = (
					{
						x = 0; y = 0;
						width = 640; height = 480;
						minDepth = 0; maxDepth = 1;
					}
				);
				scissors = (
					{
						offset = { x = 0; y = 0 };
						extent = { width = 640; height = 480; };
					},
				);
			};
			rasterization = {
				depthClampEnable = false;
				rasterizerDiscardEnable = false;
				polygonMode = fill;
				cullMode = back;
				frontFace = counter_clockwise;
				depthBiasEnable = false;
				lineWidth = 1;
			};
			multisample = {
				rasterizationSamples = $msaaSamples;
				sampleShadingEnable = false;
				minSampleShading = 0.5f;
				alphaToCoverageEnable = false;
				alphaToOneEnable = false;
			};
			depthStencil = {
				depthTestEnable = true;
				depthWriteEnable = true;
				depthCompareOp = less_or_equal;
				depthBoundsTestEnable = false;
				stencilTestEnable = false;
			};
			colorBlend = {
				logicOpEnable = false;
				attachments = ({
					blendEnable = true;
					srcColorBlendFactor = src_alpha;
					dstColorBlendFactor = one_minus_src_alpha;
					colorBlendOp = add;
					srcAlphaBlendFactor = src_alpha;
					dstAlphaBlendFactor = one_minus_src_alpha;
					alphaBlendOp = add;
					colorWriteMask = r|g|b|a;
				});
			};
			dynamic = {
				dynamicState = ( viewport, scissor );
			};
			layout = twod;
			//renderPass = renderpass;
		};
	};
	renderpass = {
		attachments = (
			{
				flags = 0;
				format = $swapchain.format;
				samples = $msaaSamples;
				loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;
				storeOp = VK_ATTACHMENT_STORE_OP_STORE;
				stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
				stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
				initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
				finalLayout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;
			},
			{
				flags = 0;
				format = VK_FORMAT_D32_SFLOAT;
				samples = $msaaSamples;
				loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;
				storeOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
				stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
				stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
				initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
				finalLayout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;
			},
			{
				flags = 0;
				format = $swapchain.format;
				samples = VK_SAMPLE_COUNT_1_BIT;
				loadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
				storeOp = VK_ATTACHMENT_STORE_OP_STORE;
				stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
				stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
				initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
				finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;
			},
		);
		subpasses = (
			{
				pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;
				colorAttachments = (
					{
						attachment = 0;
						layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;
					}
				);
				resolveAttachments = (
					{
						attachment = 2;
						layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;
					}
				);
				depthStencilAttachment = {
					attachment = 1;
					layout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;
				};
				preserveAttachments = ();
			},
		);
		dependencies = (
			{
				srcSubpass = VK_SUBPASS_EXTERNAL;
				dstSubpass = 0;
				srcStageMask = VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT;
				dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
				srcAccessMask = VK_ACCESS_MEMORY_READ_BIT;
				dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;
				dependencyFlags = VK_DEPENDENCY_BY_REGION_BIT;
			},
			{
				srcSubpass = 0;
				dstSubpass = VK_SUBPASS_EXTERNAL;
				srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
				dstStageMask = VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT;
				srcAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;
				dstAccessMask = VK_ACCESS_MEMORY_READ_BIT;
				dependencyFlags = VK_DEPENDENCY_BY_REGION_BIT;
			},
		);
	};
}
